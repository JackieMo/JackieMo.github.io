<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JackieMo</title>
    <description>读万卷书 行万里路</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 21 Dec 2017 10:55:35 +0800</pubDate>
    <lastBuildDate>Thu, 21 Dec 2017 10:55:35 +0800</lastBuildDate>
    <generator>Jekyll v3.4.0</generator>
    
      <item>
        <title>解决 iTunes 12.7 无法下载IPA包</title>
        <description>&lt;p&gt;升级 iTunes 12.7 之后，发现没有了App Store，这也意味着不能下载IPA包了。要想下载IPA包，只能降级了。&lt;/p&gt;

&lt;h3 id=&quot;降级步骤&quot;&gt;降级步骤&lt;/h3&gt;

&lt;h4 id=&quot;1下载-itunes-1263&quot;&gt;1.下载 &lt;a href=&quot;https://support.apple.com/zh-tw/HT208079&quot;&gt;iTunes 12.6.3&lt;/a&gt;&lt;/h4&gt;

&lt;h4 id=&quot;2关闭某些应用xcode&quot;&gt;2.关闭某些应用(Xcode)&lt;/h4&gt;

&lt;h4 id=&quot;3安装-itunes-1263&quot;&gt;3.安装 iTunes 12.6.3&lt;/h4&gt;

&lt;h4 id=&quot;4打开-itunes-后可能出现报错&quot;&gt;4.打开 iTunes 后可能出现报错&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://p0bkxzmll.bkt.clouddn.com/itunes_error.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;解决方法：到 ~/Music 目录下删除 iTunes 目录，重新打开即可。&lt;/p&gt;
</description>
        <pubDate>Thu, 21 Dec 2017 09:39:14 +0800</pubDate>
        <link>http://localhost:4000/2017/12/itunes/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/itunes/</guid>
        
        
      </item>
    
      <item>
        <title>NSLayoutConstraint</title>
        <description>&lt;h2 id=&quot;什么是nslayoutconstraint&quot;&gt;什么是NSLayoutConstraint?&lt;/h2&gt;

&lt;p&gt;众所周知，我们可以在xib中用Auto Layout的方式给控件添加约束，此外苹果还给我们提供了代码的方式来添加约束：NSLayoutConstraint。&lt;/p&gt;

&lt;h2 id=&quot;如何使用nslayoutconstraint&quot;&gt;如何使用NSLayoutConstraint?&lt;/h2&gt;

&lt;p&gt;在使用NSLayoutConstraint前，我们需要知道一个小的知识点：Autoresizing Mask。在 使用Auto Layout时，首先需要将视图的 &lt;code class=&quot;highlighter-rouge&quot;&gt;setTranslatesAutoresizingMaskIntoConstraints&lt;/code&gt; 设为NO。这个属性默认为YES。当它为YES是，运行时系统会自动将Autoresizing Mask转换为Auto Layout的约束，这些约束很有可能会和我们自己添加的产生冲突。我们常常会忘了做这一步，然后引起的约束报错就是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p0bkxzmll.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-15%20%E4%B8%8B%E5%8D%883.46.40.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在xib中，如果我们勾选了&lt;code class=&quot;highlighter-rouge&quot;&gt;use auto layout&lt;/code&gt;，则编译器会自动帮我们关闭Autoresizing Mask，如果是使用代码添加约束，则需要手动关闭Autoresizing Mask。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setTranslatesAutoresizingMaskIntoConstraints&lt;/code&gt; 这个方法是交给被添加约束的视图来执行的，关闭该视图的Autoresizing Mask。在添加约束前，就应该关闭该属性。&lt;/p&gt;

&lt;h2 id=&quot;使用nslayoutconstraint为视图添加约束&quot;&gt;使用NSLayoutConstraint为视图添加约束&lt;/h2&gt;

&lt;p&gt;Auto Layout 中约束对应的类为 NSLayoutConstraint，一个 NSLayoutConstraint 实例代表一条约束。&lt;/p&gt;

&lt;p&gt;NSLayoutConstraint有两个方法。&lt;/p&gt;

&lt;h4 id=&quot;第一种-constraintwithitem也是最常用的&quot;&gt;第一种 constraintWithItem:也是最常用的：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+(instancetype)constraintWithItem:(id)view1 
                        attribute:(NSLayoutAttribute)attr1 
                        relatedBy:(NSLayoutRelation)relation 
                           toItem:(nullable id)view2 
                        attribute:(NSLayoutAttribute)attr2 
                       multiplier:(CGFloat)multiplier 
                         constant:(CGFloat)c;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;前三个和被约束的视图有关，后四个和他的父视图有关。这个方法连起来可以翻译如下：view1的某个属性（attr1）等于view2的某个属性（attr2）的值的多少倍（multiplier）加上某个常量（constant）。描述的是一个view与另外一个view的位置和大小约束关系。其中属性attribute有上、下、左、右、宽、高等，关系relation有小于等于、等于、大于等于。需要注意的是，小于等于 或 大于等于 优先会使用 等于 关系，如果 等于 不能满足，才会使用 小于 或 大于。例如设置一个 大于等于100 的关系，默认会是 100，当视图被拉伸时，100 无法被满足，尺寸才会变得更大。&lt;/p&gt;

&lt;p&gt;假如我们设计一个简单的页面。一个子view在父view中，其中子view的上下左右边缘都离父view的边缘40个像素。这个我们该如何写呢？如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    self.view.backgroundColor = [UIColor yellowColor];
    
    
    UIView *subView = [[UIView alloc] init];
    subView.backgroundColor = [UIColor redColor];
    // 在设置约束前，先将子视图添加进来
    [self.view addSubview:subView];
    
    // 使用autoLayout约束，禁止将AutoresizingMask转换为约束
    [subView setTranslatesAutoresizingMaskIntoConstraints:NO];
    
    // 设置subView相对于VIEW的上左下右各40像素
    NSLayoutConstraint *constraint1 = [NSLayoutConstraint constraintWithItem:subView attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeTop multiplier:1.0 constant:40];
    NSLayoutConstraint *constraint2 = [NSLayoutConstraint constraintWithItem:subView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeLeft multiplier:1.0 constant:40];
    // 由于iOS坐标系的原点在左上角，所以设置右边距使用负值
    NSLayoutConstraint *constraint3 = [NSLayoutConstraint constraintWithItem:subView attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeBottom multiplier:1.0 constant:-40];
    
    // 由于iOS坐标系的原点在左上角，所以设置下边距使用负值
    NSLayoutConstraint *constraint4 = [NSLayoutConstraint constraintWithItem:subView attribute:NSLayoutAttributeRight relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeRight multiplier:1.0 constant:-40];
    
    // 将四条约束加进数组中
    NSArray *array = [NSArray arrayWithObjects:constraint1, constraint2, constraint3, constraint4 ,nil];
    // 把约束条件设置到父视图的Contraints中
    [self.view addConstraints:array];
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;我们再添加一个需求：
子view在父view的中间，且子view长200，高100。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ssubView在subView中间，宽高200，100
    UIView *ssubView = [[UIView alloc] init];
    ssubView.backgroundColor = [UIColor blackColor];
    [self.view addSubview:ssubView];
    [ssubView setTranslatesAutoresizingMaskIntoConstraints:NO];
    
    // 加约束
    NSLayoutConstraint *sContraint1 = [NSLayoutConstraint constraintWithItem:ssubView attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterX multiplier:1.0 constant:0];
    NSLayoutConstraint *sContraint2 = [NSLayoutConstraint constraintWithItem:ssubView attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterY multiplier:1.0 constant:0];
    NSLayoutConstraint *sConstraint3 = [NSLayoutConstraint constraintWithItem:ssubView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationGreaterThanOrEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:200];
    NSLayoutConstraint *sConstraint4 = [NSLayoutConstraint constraintWithItem:ssubView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationGreaterThanOrEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1.0 constant:100];
    
    NSArray *array2 = [NSArray arrayWithObjects:sContraint1, sContraint2,sConstraint3,sConstraint4, nil];
    [self.view addConstraints: array2];
    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里有几个注意点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果是设置view自身的属性，不涉及到与其他view的位置约束关系。比如view自身的宽、高等约束时，方法constraintWithItem:的第四个参数view2（secondItem）应设为nil；且第五个参数attire（secondAttribute）应设为NSLayoutAttributeNotAnAttribute 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在设置宽和高这两个约束时，relatedBy参数使用的是 NSLayoutRelationGreaterThanOrEqual，而不是 NSLayoutRelationEqual。因为 Auto Layout 是相对布局，所以通常你不应该直接设置宽度和高度这种固定不变的值，除非你很确定视图的宽度或高度需要保持不变。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;第二种使用比较冷门的vflvisual-format-language本质是是基于自动布局autolayout&quot;&gt;第二种，使用比较冷门的VFL(Visual Format Language)，本质是是基于自动布局(AutoLayout)。&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
+ (NSArray&amp;lt;__kindof NSLayoutConstraint *&amp;gt; *)constraintsWithVisualFormat:(NSString *)format 
                                                                options:(NSLayoutFormatOptions)opts 
                                                                metrics:(nullable NSDictionary&amp;lt;NSString *,id&amp;gt; *)metrics 
                                                                  views:(NSDictionary&amp;lt;NSString *, id&amp;gt; *)views;
 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_volumeImageView.translatesAutoresizingMaskIntoConstraints = NO;
NSArray *imageViewConstrainH = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:|-60-[_volumeImageView]-60-|&quot; 
                                                                       options:0 
                                                                       metrics:0 
                                                                         views:NSDictionaryOfVariableBindings(_volumeImageView)];
[self.view addConstraints:imageViewConstrainH];
NSArray *imageViewConstaintV = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|-150-[_volumeImageView(150)]&quot; 
                                                                       options:0 
                                                                       metrics:0
                                                                         views:NSDictionaryOfVariableBindings(_volumeImageView)];
[self.view addConstraints:imageViewConstaintV];

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;format：指定约束的格式。更多信息，在&lt;a href=&quot;https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/index.html&quot;&gt;Auto Layout Guide&lt;/a&gt;查看&lt;a href=&quot;https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html&quot;&gt;Visual Format Language&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;opts：描述在视觉格式化字符串中的布局属性和方向&lt;/li&gt;
  &lt;li&gt;metrics：将出现在视觉格式化字符串的常量字典。字典的Keys必须是在出现在视觉格式化字符串的字符串类型，对应的values必须是NSNumber对象&lt;/li&gt;
  &lt;li&gt;views：出现的视觉格式化字符串的字典view，所有的Keys必须是使用在视觉格式化字符串的字符串类型，对应的values必须是view对象。&lt;/li&gt;
  &lt;li&gt;返回值：一个约束组合的数组，像视觉格式化字符串描述的一样表述了在提供的视图和它们的父视图之间的关系。所有的约束以在视觉格式化字符串被指定的约束顺序一致。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;实践&quot;&gt;实践&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;每条约束格式字符串分水平(H，可省略)和垂直方向(V)。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; 代表父视图。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; 代表标准间距，两个子视图直接的值是8，与父视图之间的值是16。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[view]&lt;/code&gt; 每个视图必须用[]包裹起来，否则语法错误。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[view(&amp;gt;=44)]&lt;/code&gt; 可以为每个视图设置一些属性或者关系，写一个紧跟view后的括号集合，支持宽高，优先级，和其它视图之间的关系。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[view@20]&lt;/code&gt; 可以设置视图的约束的优先级，以@开头，取值范围(0 1000]。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[view1]-20-[view2]&lt;/code&gt; 可以指定view之间的水平或者垂直间距，写在 - 对 - 即可。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[view1][view2]&lt;/code&gt; 如果 - 省略则他们之间的距离为0。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[flexibleButton(&amp;gt;=70,&amp;lt;=100)]&lt;/code&gt; 多个条件之间用,连接并且之间不能有空格。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;注意事项&quot;&gt;注意事项&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;使用时，必须把view的&lt;code class=&quot;highlighter-rouge&quot;&gt;translatesAutoresizingMaskIntoConstraints&lt;/code&gt;属性设置为NO，否则约束可能更预期不一致。这是一个历史遗留的问题，由于在&lt;code class=&quot;highlighter-rouge&quot;&gt;AutoLayout&lt;/code&gt;诞生以前一直使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Autoresizing&lt;/code&gt;来控制布局&lt;/li&gt;
  &lt;li&gt;重写&lt;code class=&quot;highlighter-rouge&quot;&gt;updateConstraints()&lt;/code&gt;方法，在里面计算约束，然后调用&lt;code class=&quot;highlighter-rouge&quot;&gt;setNeedsUpdateConstraints()&lt;/code&gt;触发更新约束。&lt;/li&gt;
  &lt;li&gt;系统计算布局顺序:
    &lt;ul&gt;
      &lt;li&gt;updateConstraints()&lt;/li&gt;
      &lt;li&gt;layoutSubviews()&lt;/li&gt;
      &lt;li&gt;drawRect(_:)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;系统计算布局顺序参考
  &lt;img src=&quot;http://p0bkxzmll.bkt.clouddn.com/autolayout.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参考链接：
  &lt;a href=&quot;http://blog.wangruofeng007.com/blog/2017/03/02/vflshen-ru-qian-chu/&quot;&gt;VFL深入浅出&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 15 Dec 2017 13:45:14 +0800</pubDate>
        <link>http://localhost:4000/2017/12/NSLayoutConstraint/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/NSLayoutConstraint/</guid>
        
        
      </item>
    
      <item>
        <title>Mac配置RN开发环境</title>
        <description>&lt;h4 id=&quot;一安装-nodewatchmanreact-native-cli在mac上我们可以通过homebrew进行相关的安装&quot;&gt;一、安装 node、watchman、react-native-cli。在Mac上我们可以通过&lt;a href=&quot;https://brew.sh/&quot;&gt;HomeBrew&lt;/a&gt;进行相关的安装。&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. brew install node
2. brew install watchman
3. brew install flow
4. npm install -g react-native-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;二ios-开发环境搭建&quot;&gt;二、ios 开发环境搭建&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. react-native init AwesomeProject 
2. cd AwesomeProject
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 06 Dec 2017 09:05:14 +0800</pubDate>
        <link>http://localhost:4000/2017/12/RN/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/RN/</guid>
        
        
      </item>
    
      <item>
        <title>First Article</title>
        <description>&lt;h3 id=&quot;new-blog-new-article&quot;&gt;new blog new article!!!&lt;/h3&gt;

&lt;p&gt;忙了一段时间后，终于闲下来了。
没事逛逛大牛的技术博客，比起自己之前配置的Hexo, 发现更喜欢喵神的博客样式。
于是心血来潮重新搭了一个新的博客，在这里要感谢喵神在github上的提供的主题&lt;a href=&quot;https://github.com/onevcat/vno-jekyll&quot;&gt;Vno-Jekyll&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;用jekyll搭建的github-pages个人博客&quot;&gt;用Jekyll搭建的Github Pages个人博客&lt;/h3&gt;

&lt;h4 id=&quot;一github上新建项目&quot;&gt;一、GitHub上新建项目&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;项目名：(username).github.io ，克隆到本地&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;二安装本地jekyll环境步骤&quot;&gt;二、安装本地Jekyll环境步骤&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;打开终端，执行 sudo gem install jekyll&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cd到项目根目录，安装bundle（sudo gem install bundle）, 再执行 bundle install&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;开启jekyll环境， bundle exec jekyll serve&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在浏览器中输入&lt;a href=&quot;http://127.0.0.1:4000/&quot;&gt;http://127.0.0.1:4000/&lt;/a&gt;，即可看到博客了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;三绑定个人域名&quot;&gt;三、绑定个人域名&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在代码仓库中新建文件 CNAME，不带后缀名&lt;/li&gt;
  &lt;li&gt;填入域名（mozj.info)，域名是在&lt;a href=&quot;https://sg.godaddy.com/&quot;&gt;godaddy&lt;/a&gt;上买的&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;四域名解析&quot;&gt;四、域名解析&lt;/h4&gt;

&lt;p&gt;可以用dnspod&lt;/p&gt;

&lt;h4 id=&quot;五评论功能&quot;&gt;五、评论功能&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;用的是&lt;a href=&quot;https://disqus.com/&quot;&gt;disqus&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;setting -&amp;gt; add disqus to site -&amp;gt; start using engage -&amp;gt; 设置自己的disqus url&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;六图片存储&quot;&gt;六、图片存储&lt;/h4&gt;

&lt;p&gt;可以用七牛&lt;/p&gt;

</description>
        <pubDate>Sat, 02 Dec 2017 10:11:24 +0800</pubDate>
        <link>http://localhost:4000/2017/12/Hi/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/Hi/</guid>
        
        
      </item>
    
  </channel>
</rss>
